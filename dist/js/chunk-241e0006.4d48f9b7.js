(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-241e0006"],{"00e6":function(n,e,t){"use strict";t.d(e,"a",function(){return a});var a=[{title:"初识TypeScript",content:"<p>当今前端界有个愈发明显的趋势，那就是使用TypeScript代替JavaScript。那TypeScript有什么魔力让越来越多的人选择它呢？</p>\n<p>首先就是js是一种动态类型语言，我们声明某个变量时，是不用声明它是什么类型的，等后面给它赋值了，它自己根据赋的值去变换类型。注意这里不是第一次赋值，而是每次赋值都可以变换类型。</p>\n<pre class=\"ql-syntax\">let a;\ntypepf(a) // \"undefined\"\na = 2;\ntypeof(a) // \"number\"\na = '123'\ntypeof(a) // \"string\"\n</pre>\n<p>这个特性可以方便我们轻松转换变量的类型，同时，也方便我们写bug来祸害下一个接手项目的人</p>\n<pre class=\"ql-syntax\">let a = 1\na += '1'\nconsole.log(a) // \"11\"\n</pre><p>这里如果没有注意到相加的两个值是不同类型的话，就出bug了。</p>\n<p>而如果你用的是TypeScript，那这个就不是问题了。</p>\n<p>TypeScript声明变量的时候，需要告知它是什么类型的。然后在赋值如果赋的是其他类型的值，那TypeScript就直接会告诉你，嘿兄弟，这里的类型错了哟。。</p>\n<pre class=\"ql-syntax\">let a: string = 123\n// error TS2322: Type '123' is not assignable to type 'string'.\n</pre>\n<p>TypeScript里有boolean、number、string、void、null、undefined、any这些类型。这里面void指的是给没有返回值的时候用的。比如</p>\n<pre class=\"ql-syntax\">function alertName(): void{\n  alert('我的名字叫XXX')\n}\n</pre>\n<p>而这里的any类型就和普通js变量一样了，它可以赋任何类型的值。</p>\n<pre class=\"ql-syntax\">let a:any = 123\na = \"321\"\nconsole.log(a) // \"321\"\n</pre>\n<p>如果我们一开始声明变量的时候没有声明类型的话，也会默认类型是any，可以随意给它赋值。不过要是声明的时候一并赋了值，TypeScript就会智能的给你推算类型。</p>\n<pre class=\"ql-syntax\">let a\na = 123\na = \"hello\"\nconsole.log(a) // \"hello\"\n\nlet b = 123\nb = \"hello\"\nconsole.log(b) // error TS2322: Type '\"hello\"' is not assignable to type 'number'.\n</pre>\n<p>那可能就有人会担心了，如果有某个变量可能是number也可能是string该怎么办？只能用any吗？那不小心赋了其他类型的怎么办？</p>\n<p>不必担心，TypeScript可以设置联合类型</p>\n<pre class=\"ql-syntax\">let a: string | number\na = \"123\"\nconsole.log(a) // \"123\"\na = 321\nconsole.log(a) // 321\n</pre>\n<p>在使用联合类型的时候，要注意，此时变量能调用的方法，只能是联合类型里面所有类型都通用的方法。</p>\n<pre class=\"ql-syntax\">function getLength(sth: number | string):number{\n  return sth.length\n}\nconsole.log(getLength('1234'))\n//error TS2339: Property 'length' does not exist on type 'string | number'.\n  Property 'length' does not exist on type 'number'.\n\nfunction getString(sth: number | string):string{\n  return sth.toString()\n}\nconsole.log(getString(4321)) // \"4321\"\n</pre>\n<p>TypeScript还可以对值的结构进行类型检查，在这里是接口interface来为这些类型命名。</p>\n<pre class=\"ql-syntax\">interface Test{\n  a: string;\n  b: number;\n}\nlet a: Test ={\n  a: '123',\n  b: '321'\n}\n</pre>\n<p>注意接口定义了哪些属性，变量也必须有这些属性，不能多也不能少。如果真的有一些可能有也可能没有的属性，可以使用“可选属性”。</p>\n<pre class=\"ql-syntax\">interface Test{\n  a: string;\n  b: number;\n  c?: boolean;\n}\nlet a: Test ={\n  a: '123',\n  b: '321'\n}\nlet b:Test ={\n  a: 'hello',\n  b: 10086,\n  c: true\n}\n</pre>\n<p>此时虽然有可选属性，但依然不可以添加一些未定义的属性。如果想添加未定义的属性，需要使用“任意属性”</p>\n<pre class=\"ql-syntax\">interface Test{\n  a: string;\n  b: number;\n  c?: boolean;\n  [propName: string]: any;\n}\nlet a: Test ={\n  a: '123',\n  b: 321,\n  c: false,\n  d: 998\n}\n</pre>\n<p>注意如果使用任意属性，那确定属性的类型都必须是任意属性的子属性。</p>\n<pre class=\"ql-syntax\">interface Test{\n  a: string;\n  b: number;\n  c?: boolean;\n  [propName: string]: string;\n}\nlet a:Test ={\n  a: '321',\n  b: 123,\n  c: false,\n  d: '456'\n}\n//error TS2411: Property 'b' of type 'number' is not assignable to string index type 'string'.\nerror TS2411: Property 'c' of type 'boolean' is not assignable to string index type 'string'.\nerror TS2322: Type '{ a: string; b: number; c: false; d: string; }' is not assignable to type 'Test'.\n  Property 'b' is incompatible with index signature.\n    Type 'number' is not assignable to type 'string'.\n</pre>\n<p>有些时候我们希望某个属性赋值之后就不要再变，这时候我们可以使用只读属性</p>\n<pre class=\"ql-syntax\">interface Test{\n  readonly a: string;\n  b: number;\n}\nlet a:Test ={\n  a: '123',\n  b: 321\n}\na.a = '456' // error TS2540: Cannot assign to 'a' because it is a constant or a read-only property.\n</pre>\n<p>我们还可以合并接口</p>\n<pre class=\"ql-syntax\">interface Test{\n  a: string;\n}\ninterface Test{\n  b: number;\n}\nlet a:Test ={\n  a: '123',\n  b: 321\n}\n</pre>\n<p>使用TypeScript声明数组，可以这么做</p>\n<pre class=\"ql-syntax\">let arr:number[] = [1,2,3]\n\ninterface StrArr{\n  [index: number]: string\n}\nlet strArr:StrArr = ['1','2','3']\n</pre><p>一旦定义了是number类型，那数组里的元素就全都只能是number，任何会使数组内出现非number类型元素的操作都会报错。</p><p>使用TypeScript声明函数，可以这么做</p><pre class=\"ql-syntax\" spellcheck=\"false\">function sum(x: number, y: number): number {\n  return x + y;\n}\n\nlet mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {\n   return x + y;\n};\n\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  return source.search(subString) !== -1;\n}\n</pre>\n<p>第一种好理解，第二种是什么意思呢？我们可以拆开三部分来看</p>\n<p>let mySum:<span style=\"color: rgb(0, 102, 204);\">&nbsp;(x: number, y: number) =&gt; number&nbsp;</span>=function (x: number, y:number): number {</p><p>  return x + y;</p><p>}</p>\n<p>很明显第一部分是给函数命名，蓝色的第二部分则是类型定义，这里的=&gt;和es5的箭头函数并不是一个东西，这里的=&gt;的左边是函数的输入类型，=&gt;右边是函数的输出类型。在这个例子的话，就是说函数两个参数都是number类型，最后函数的输出也是number的值。</p>\n<p>而第三种，通过接口的也很好懂，两个输入的参数是string类型，输出则是boolean类型。</p>\n<p>在TypeScript里用函数也可以使用可选参数和默认值</p>\n<pre class=\"ql-syntax\">function buildName(firstName: string = 'Tom', lastName?: string) {\n  if (lastName) {\n    return firstName + ' ' + lastName;\n  } else {\n     return firstName;\n  }\n}\nlet tomcat = buildName('Tom', 'Cat');\nlet tom = buildName('Tom');\n</pre>\n<p>如果我们输入的参数是联合类型，而在函数内要分情况的时候，可以使用类型断言。</p>\n<pre class=\"ql-syntax\">function getLength(something: string | number): number {\n  if ((&lt;string&gt;something).length) {\n    return (&lt;string&gt;something).length;\n  } else {\n    return something.toString().length;\n  }\n}\n</pre>\n<p>这里的&lt;string&gt;的意思就是人为断言此时的something是string类型。</p>\n<p>TypeScript里还有很多内置对象可供使用</p>\n<pre class=\"ql-syntax\">let b: Boolean = new Boolean(1);\nlet d: Date = new Date();\nlet body: HTMLElement = document.body;\nlet allDiv: NodeList = document.querySelectorAll('div');\n</pre>\n<p>如果我们想使用内部元素是不同类型的数组，可以选择使用元祖</p>\n<pre class=\"ql-syntax\">let xcatliu: [string, number] = ['Xcat Liu', 25];</pre>\n<p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型。</p>\n<p>如果我们想声明一些取值被限定在一定范围的对象时，可以使用枚举类型的对象</p>\n<pre class=\"ql-syntax\">enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};\nconsole.log(Days[\"Sun\"] === 0);\n</pre>\n<p>我们也可以手动给枚举项赋值</p>\n<pre class=\"ql-syntax\">enum Days {Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat};\n</pre>\n<p>1像例子这样赋值的时候需要注意，枚举项中没有赋值的，会根据前一项的值来确定自己的值，所以这里的Tue是2，Wed是3。。所以如果这里的Sun是2的话，Tue也是2，取值的时候就会出错。这个特点也决定了，如果要手动给枚举项赋值，除非是赋number类型的，否则就得给所有的项都赋值。</p>\n<p>TypeScript也可以使用类</p>\n<p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 public、private 和 protected。</p>\n<ul>\n<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li>\n<li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>\n<li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li>\n</ul>\n<pre class=\"ql-syntax\" spellcheck=\"false\">class Animal {\n&nbsp; public name:string;\n&nbsp; private age:number;\n&nbsp; protected sex:string;\n&nbsp; public constructor(name, age, sex) {\n&nbsp; &nbsp; this.name = name;\n&nbsp; }\n}\nclass Cat extends Animal {\n&nbsp; constructor(name, age, sex) {\n&nbsp; &nbsp; super(name, age, sex);\n&nbsp; &nbsp; console.log(this.sex);\n&nbsp; }\n}\nlet a = new Animal('jack', 20, 'boy');\n</pre>\n<p>TypeScript里还有一种称为抽象类的，它不能实例化，而且它里面的抽象方法必须被子类实现</p>\n<pre class=\"ql-syntax\">abstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\nclass Cat extends Animal {\n  public sayHi() {\n    let names = this.name;\n    console.log('Meow, My name is ' + names);\n  }\n}\nlet cat = new Cat('Tom');\n</pre>\n<p>假如我们想要使用一些第三方库的时候，需要先声明。通常我们会把类型声明放到一个单独的文件中，这就是声明文件。</p>\n<pre class=\"ql-syntax\">declare var jQuery: (selector: string) =&gt; any;</pre>\n<p>网上已经有人写好了类型文件，可以直接下载 <a href=\"http://microsoft.github.io/TypeSearch/\" target=\"_blank\">声明文件</a></p>",time:"2019",type:"Javascript",copyright:"original",query:{name:"初识TypeScript"},link:"/blogDetail",summary:"当今前端界有个愈发明显的趋势，那就是使用TypeScript代替JavaScript",tag:["CSS"]},{title:"CSS预处理",content:'<p>我们有时候会遇到一个尴尬的情况，那就是css没办法“编程”。</p>\n<p>来看这么一个案例：</p>\n<p>css做一个loading图标，我们需要很多个圆点，然后又要控制他们的位置还有出现以及消失的时间。如果单纯用css来写，那要写很多遍代码，而且代码相似度还非常高。为之奈何？</p>\n<p>我们可以使用css预处理来解决。这里使用的是sass</p>\n<iframe height="265" style="width: 100%;" scrolling="no" title="vqroBG" src="//codepen.io/vinson2088/embed/vqroBG/?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/vqroBG/\'>vqroBG</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>',time:"2019",type:"CSS3",copyright:"notes",query:{name:"CSS预处理"},link:"/blogDetail",summary:"我们有时候会遇到一个尴尬的情况，那就是css没办法“编程”",tag:["CSS"]},{title:"在vue上做动画",content:'<p>我们都知道，在vue里面我们用&lt;transition&gt;组件将要做动画的元素包裹起来，然后可以使用几个钩子去设置动画效果。</p>\n<pre class="ql-syntax">&lt;template&gt;\n  &lt;div&gt;\n    &lt;transition name="slide-fade"&gt;\n      &lt;div v-show="toggle"&gt;下拉展开，往上闭合&lt;/div&gt;\n    &lt;/transition&gt;\n    &lt;button @click="toggle = !toggle"&gt;按钮&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{\n      toggle: true\n    }\n  }\n}\n&lt;/script&gt;\n&lt;style spoce&gt;\n.slide-fade-enter-active{\n&nbsp; transition: all .3s ease;\n}\n.slide-fade-leave-active{\n&nbsp; transition: all .8s ease\n}\n.slide-fade-enter,.slide-fade-leave-to{\n&nbsp; transform: translateY(-10px);\n&nbsp; opacity: 0;\n}\n&lt;/style&gt;\n</pre>\n<p>那如果我们图方便想使用一些第三方库呢？比如Animate.css，该怎么做？</p>\n<p>我们可以在transition组件上\'enter-active-class="animated effect"\'和\'leave-active-class="animated effect"\'。两个effect分别是你所要添加到元素上的从Animate.css上找到的class名。这样我们就可以使用Animate.css上的东西了。</p>\n<pre class="ql-syntax">&lt;template&gt;\n  &lt;div&gt;\n    &lt;transition name="slide-fade" enter-active-class="animated bounce" leave-active-class="animated bounce"&gt;\n      &lt;div v-show="toggle"&gt;下拉展开，往上闭合&lt;/div&gt;\n    &lt;/transition&gt;\n    &lt;button @click="toggle = !toggle"&gt;按钮&lt;/button&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{\n      toggle: true\n    }\n  }\n}\n&lt;/script&gt;\n</pre>',time:"2019",type:"CSS3",copyright:"notes",query:{name:"在vue上做动画"},link:"/blogDetail",summary:"当我们遇到一个很多图片的页面，该如何提高页面访问速度？",tag:["CSS","Vue.js","animate.css"]},{title:"懒加载",content:'<p>当我们遇到一个很多图片的页面，该如何提高页面访问速度？</p>\n<p>图片很多，所以HTTP请求的数量也多。图片本身的体积也不小，再怎么压缩体积也不能小到哪里去，而且加载也需要时间。为之奈何？</p>\n<p>凡事总会有解决的办法，虽然页面图片很多，但是屏幕能容纳的图片就不多了，很多图片其实是在屏幕外的。那部分图片在一开始的时候其实可以用其他的东西替代它，等到页面快滚动到那里的时候，再去把图片加载出来。这样的方法就是懒加载。也即：一开始不加载，等要用到的时候再加载。</p>\n<p>有了懒加载，HTTP请求数一下子就降下去了，需要加载的图片数量也降下去了。访问速度当然也就有了飞一般的提升。</p>\n<p>基于这么一个思路我们来实现一个简单的懒加载</p>\n<pre class="ql-syntax">&lt;div&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n  &lt;img class="r-img" alt="图片" data-src="./test.jpg"&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  const imgList = document.querySelectorAll(\'.r-img\')\n  const windowHeight = window.innerHeight\n  let num = 0\n  function lazyload(){\n    for(let i = num; i &lt; imgList.length; i++){\n      let minus = windowHeight - imgList[i].getBoundingClientRect().top\n      if(minus &gt; 0){\n        imgList[i].src = imgList[i].getAttribute(\'data-src\')\n        num = i + 1\n      }\n    }\n  }\n  window.addEventListener(\'scroll\', lazyload, false)\n&lt;/script&gt;\n</pre>\n<p>至此我们完成了一个最基本的懒加载函数，但这个仍然是有缺陷的。因为scroll太容易触发了，而且触发的频率非常高，我们可以结合上一篇文章的防抖节流来优化它。</p>\n<pre class="ql-syntax">&lt;script&gt;\n  const imgList = document.querySelectorAll(\'.r-img\')\n  const windowHeight = window.innerHeight\n  let num = 0\n  function lazyload(){\n    for(let i = num; i &lt; imgList.length; i++){\n      let minus = windowHeight - imgList[i].getBoundingClientRect().top\n      if(minus &gt; 0){\n        imgList[i].src = imgList[i].getAttribute(\'data-src\')\n        num = i + 1\n      }\n    }\n  }\n  function throttleDebounce(fn, delay){\n    let last = 0, timer = null\n    return function(){\n      let that = this\n      let arg = arguments\n      let now = +new Date()\n      if(now - last &gt; delay){\n        last = now\n        fn.apply(that, arg)\n      } else {\n        clearTimeout(timer)\n        timer = setTimeout(function(){\n          last = now\n          fn.apply(that, arg)\n        }, delay)\n      }\n    }\n  }\n  const betterlazyload = throttleDebounce(lazyload, 500)\n  window.addEventListener(\'scroll\', betterlazyload, false)\n&lt;/script&gt;\n</pre>\n<p>有一点需要注意，就是图片没有地址时候的高度问题。可使用div占位之类的方法解决。这里就简单的直接去设置高度。</p>\n<iframe height="265" style="width: 100%;" scrolling="no" title="ydqNYL" src="//codepen.io/vinson2088/embed/ydqNYL/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/ydqNYL/\'>ydqNYL</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>',time:"2019",type:"Javascript",copyright:"notes",query:{name:"懒加载"},link:"/blogDetail",summary:"当我们遇到一个很多图片的页面，该如何提高页面访问速度？",tag:["Javascript"]},{title:"防抖与节流",content:'<blockquote class="reference">本文参考掘金小册《前端性能优化原理与实践》。以下是小册链接：<a class="link" href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank">《前端性能优化原理与实践》</a></blockquote>\n<p>假设现在给mouseover绑定了一个持续1秒钟的向下展开事件，mouseout绑定向上闭合事件。那在一秒钟之内鼠标多次滑过会发生什么情况？</p>\n<iframe height="265" style="width: 100%;" scrolling="no" title="trigger" src="//codepen.io/vinson2088/embed/YojZZG/?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/YojZZG/\'>trigger</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<p>答案是鼠标离开后，元素还会继续展开闭合多次。但很明显这个并不是我们要的效果。再想象这么一个场景，我们给某个按钮绑定了提交表单的事件。那万一用户手抖了或者帕金森了点击多次了会怎样？答案就是表单也会被提交很多次。如何防止这种情况？</p>\n<p>有这么两种方式：</p>\n<p>1、使用遮罩层，阻止用户多次点击提交按钮。但这个只适合于这种提交事件。</p>\n<p>2、使用事件防抖或者事件节流防止多次触发。</p>\n<p>防抖和节流都是以闭包的形式，通过setTimeout来控制事件触发的频率。</p>\n<h3>防抖</h3>\n<p>实现防抖的思路是，当事件触发之后，会等待一段时间，比如说等1秒。如果在这一秒钟里又触发了一次事件，则清空已经等待的时间继续等待1秒。</p>\n<p>基于这个思路，我们来写这么一个防抖函数</p>\n<pre class="ql-syntax">function debounce(fn, delay){\n  let timer = null //定时器\n  return function(){\n    let that = this\n    let arg = arguments\n    if(timer){\n      clearTimeout(timer)  //触发事件的时候将之前的定时器清掉\n    }\n    timer = setTimeout(function(){  //设置新的定时器开始计时\n      fn.apply(that, arg)\n    }, delay)\n  }\n}\n</pre>\n<iframe height="265" style="width: 100%;" scrolling="no" title="debounce" src="//codepen.io/vinson2088/embed/OewpVm/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/OewpVm/\'>debounce</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<h3>节流</h3>\n<p>实现节流的思路与防抖有些不一样，节流是当事件触发了之后，等待一段时间里，如果又触发了这个事件，不去理会后面触发的事件，在等待结束后执行这个触发的事件。</p>\n<p>基于这个思路，我们来写这么一个节流函数</p>\n<pre class="ql-syntax">function throttle(fn, interval){\n  let last = 0  //上一次触发事件的时间\n  return function(){\n    let that = this\n    let arg = arguments\n    let now = +new Date()  //本次触发事件的事件\n    if(now - last &gt; interval){\n      last = now\n      fn.apply(that, arg)\n    }\n  }\n}\n</pre>\n<iframe height="265" style="width: 100%;" scrolling="no" title="throttle" src="//codepen.io/vinson2088/embed/vqaxxy/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/vqaxxy/\'>throttle</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<h3>会节流的防抖函数</h3>\n<p>其实上面实现的防抖函数存在一个bug，那就是，如果我一直触发事件的话，防抖函数一直清空等待时间，那事件就一直不会响应。我们可以利用节流的思想给防抖加上另外一个等待时间，如果超过了这个等待时间，就会响应触发的事件。</p>\n<pre class="ql-syntax">function throttleDebounce(fn, delay){\n  let last = 0, timer = null\n  return function(){\n    let that = this\n    let arg = arguments\n    let now = +new Date()\n    if(now - last &gt; delay){\n      last = now\n      fn.apply(that, arg)\n    } else {\n      clearTimeout(timer)\n      timer = setTimeout(function(){\n        last = now\n        fn.apply(that, arg)\n      }, delay)\n    }\n  }\n}\n</pre>\n<iframe height="265" style="width: 100%;" scrolling="no" title="throttleDebounce" src="//codepen.io/vinson2088/embed/bPjxLv/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/bPjxLv/\'>throttleDebounce</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n<p>关于防抖和节流就介绍到这，如果担心防抖和节流会记混的话，可以构建这么一个场景帮助记忆：</p>\n<p>有一个大院一群学生要去学校。我们把去上学看作触发的事件。如果他们各自开车过去当然是可以的，不过车太多可能就会堵塞交通。这就是没有任何防抖节流的效果。如果他们坐公交车过去，我们知道公交车司机是不会等你的，上车了多少人就多少人，司机只看时间，时间一到就开车。这就是节流。如果他们坐黑车过去，黑车司机看到有人上车了，就很开心，会觉得再等一会儿可能就又会有一个人上车，他就可以多赚一些，所以会继续等。除非是上来一个之后等了很久都没人，司机才会放弃等待，开车出发。这就是防抖。那如果黑车司机一直在等人上车的话也不行啊，学生们会担心迟到所以车上的学生会一直催促黑车司机，给他一个时间，到点了就一定要走。这个就是经过节流思想优化的防抖。</p>',time:"2019",type:"Javascript",copyright:"notes",query:{name:"防抖与节流"},link:"/blogDetail",summary:"假设现在给mouseover绑定了一个持续1秒钟的向下展开事件，mouseout绑定向上闭合事件",tag:["Javascript"]},{title:"性能优化一二事",content:'<blockquote class="reference">本文参考掘金小册《前端性能优化原理与实践》。以下是小册链接：<a class="link" href="https://juejin.im/book/5b936540f265da0a9624b04b" target="_blank">《前端性能优化原理与实践》</a></blockquote>\n<p>前端页面打开很慢的原因有很多种。从页面数据请求的到渲染这个角度来看，打开一个网页，要经过这么几个步骤：</p>\n<p>1、DNS解析</p>\n<p>2、TCP请求</p>\n<p>3、HTTP请求</p>\n<p>4、服务端处理，返回HTTP响应</p>\n<p>5、浏览器解析响应数据，渲染出来</p>\n<p>这当中，前端工程师最需着力的是第3步和第5步。</p>\n<p>首先先来看HTTP请求。</p>\n<h3>优化HTTP请求</h3>\n<p>有两个方向可以努力，一个是减少HTTP请求数，一个是减少单次请求所花费的时间。这两者我们都可以用压缩合并资源的方式去做。而压缩合并资源，就不能不提到webpack。</p>\n<p>常见的webpack优化方式，有使用include和exclude来规避一些不必要的转译，还有开启缓存将转译结果缓存到文件系统。</p>\n<pre class="ql-syntax">module:{\n  rules:[\n    {\n      test:/.js$/,  //匹配js文件\n      exclude:/(node_modules|bower_components)/,  //将这两个文件夹的文件除外\n      use:{\n        loader:\'babel-loader?cacheDirectory=true\',  //?cacheDirectory=true表示开启缓存\n        options:{\n          presets:[\'@babel/preset-env\']\n        }\n      }\n    }\n  ]\n}\n</pre>\n<p>此外还可以使用DllPlugin处理文件，让第三方库不会一起重新打包；使用happyHappypack将loader从单线程变成多线程；使用Tree-shaking删除冗余代码；</p>\n<h3>使用缓存</h3>\n<p>浏览器缓存机制有4种，分别是：</p>\n<p>1、Memory Cache</p>\n<p>2、Service Worker Cache</p>\n<p>3、HTTP Cache</p><p>4、Push Cache</p>\n<p>我们来看HTTP Cache</p>\n<p>HTTP缓存分两种，一个是强缓存，一个是协商缓存。</p>\n<p>强缓存是利用http头中的Expires和Cache-control来控制的。当有请求发出的时候，浏览器会根据这两个字段判断目标资源是否命中强缓存，如果命中了，则直接从缓存中拿数据。Expires是时间戳，Cache-control则是使用max-age来控制资源的有效期。</p>\n<pre class="ql-syntax">expires: Tue Jul 02 2019 15:41:24 GMT+0800 (中国标准时间)\ncache-control: max-age=31536000\n</pre>\n<p>协商缓存会跟服务器通信询问缓存信息，从而判断是从服务器下载数据还是从缓存中拿数据。</p>\n<p>我们开启协商缓存之后，第一次请求数据，响应头会出现Last-Modified字段，它是一个时间戳。在下一次请求的时候，请求头都会带上一个叫if-Modified-Since的时间戳字段，服务器会对比这个时间戳与资源在服务器上的最后修改时间，如果不一致，便会返回资源，并在返回头带上新的Last-Modified。否则就返回304，返回头也不加Last-Modified。</p>\n<p>使用这个方式获取缓存，会有一个bug，就是服务器无法正确感知文件是否改变，可能会在不需要返回资源时也返回，或者需要返回新资源时不返回。我们可以使用Etag字段来解决。</p>\n<p><br></p>\n<p>接下来来看浏览器解析部分。</p>\n<p>要优化浏览器解析，首先就得知道浏览器是怎么一步步将页面加载出来的。一般浏览器是经过这么几个步骤：</p>\n<p>1、解析HTML</p>\n<p>2、计算样式</p>\n<p>3、计算图层布局</p>\n<p>4、绘制图层</p>\n<p>5、整合图层</p>\n<p>以上几个步骤，用文字描述就是：解析HTML得到DOM树，解析得到CSSOM树，合并DOM树和CSSOM树得到render树，从根节点开始计算每个元素的大小位置等信息，得到基于render树的布局渲染树。最后以布局渲染树为蓝本计算布局绘制图像。</p>\n<p>后面当有新元素加入时，浏览器会通过css引擎查找css样式表，找到符合该元素的样式添加到它上面，然后重新绘制页面。这也就有了第一个优化点，css的优化。</p>\n<p>css的匹配是从右往左的，因此我们需少用标签选择器，尤其是通配符*。关注可以通过继承实现的属性，避免重复匹配。还有就是减少嵌套层数。</p>\n<p>css的解析也是会阻塞渲染的，因此要将它尽量往前放，尽早下载尽早解析。说到阻塞渲染，js也是会的。当浏览器遇到script标签，会暂停渲染过程，控制权去到js引擎，此时开始执行js语句。等执行完毕后，控制权再回到渲染引擎，此时再继续刚刚的渲染。因此，我们要将js代码尽量往后放，避免它阻塞渲染。或者是使用async模式或者defer模式加载js文件。async模式下，js不会阻塞浏览器做其他事，它的加载是异步的，在它加载结束的时候，会立即执行。defer模式下，加载也是异步的，但执行是推迟的。它会等整个文档解析完成，DOMContentLoaded事件触发前才会执行。</p>\n<h3>回流与重绘</h3>\n<p>我们知道js其实是很快的，但是操作DOM却不快。原因是因为js引擎和渲染引擎是相互独立的，两者通信需要特殊的桥接接口作为桥梁，因而会显得不快。再者，操作DOM可能会出现“回流”或者“重绘”，这也是拖慢速度的一个原因。</p>\n<p>所谓的回流，指的是我们操作DOM的时候，元素发生了几何尺寸的变化，比如改变了宽度，使得浏览器要重新计算元素的几何属性再重新绘制出来。</p>\n<p>而重绘则是指我们操作DOM的时候没有发生几何尺寸的变化，比如只是改变了颜色，浏览器不用重新计算元素几何属性，直接给那个元素绘制新的样式就可以。</p>\n<p>两者相比较的话，明显是重绘对速度的影响要小。但这并不意味着可以随性任意去改，毕竟也是要耗性能的东西，能少则少。</p>\n<p>会导致回流的操作</p>\n<p>1、改变元素的几何属性</p>\n<p>2、改变DOM树结构</p>\n<p>3、获取一些需要实时计算的属性值比如offsetHeight之类的</p>\n<h3>Event loop来看渲染时机</h3>\n<p>一个event loop过程，一般有这么几个步骤</p>\n<p>1、执行主线程任务</p>\n<p>2、主线程任务执行完毕，查看当前有没有微任务</p>\n<p>3、如果有微任务，执行微任务</p>\n<p>4、<strong>渲染页面</strong></p>\n<p>5、将任务队列中的第一个任务推入主线程</p>\n<p>6、重复以上过程</p>\n<p>所以说，如果我们想异步更新处理DOM，将它包装成微任务才是好选择。</p>\n<h3>事件节流，防抖，lazyload</h3>\n<p>后面再讲</p>',time:"2019",type:"HTML5",copyright:"notes",query:{name:"性能优化一二事"},link:"/blogDetail",summary:"前端页面打开很慢的原因有很多种。从页面数据请求的到渲染这个角度来看，打开一个网页，要经过这么几个步骤",tag:["HTML","CSS","webpack"]},{title:"Vue相关",content:"<p>Vue.js是我们常用的一个前端框架，下面我们就来复习一下它</p>\n<h3>1、生命周期钩子</h3>\n<p>1.1、beforeCreate</p>\n<p>在这里初始化事件，生命周期。因为数据还没挂载，所以我们是获取不到props和data中的数据。</p>\n<p>1.2、created</p>\n<p>在这里挂载数据，绑定事件。所以可以获取到props和data了，但因为组件还没挂载，所以还不能看到。一般在这里去获取初始数据</p>\n<p>1.3、beforeMount</p>\n<p>在这里找实例或者组件对应的模板，编译模板成VDOM，放入render函数准备渲染。也在这里可以去获取初始数据</p>\n<p>1.4、mounted</p>\n<p>这里将VDOM渲染成真实DOM。此时组件已经挂载，数据，真实DOM也处理完成。</p>\n<p>1.5、beforeUpdate</p>\n<p>在数据更新之前会调用</p>\n<p>1.6、updated</p>\n<p>在数据更新之后调用</p>\n<p>1.7、beforeDestroy</p>\n<p>在调用$destroy方法后，会调用这个钩子函数。可以在这里清理计时器，移除事件等</p>\n<p>1.8、destroyed</p>\n<p>组件的绑定，监听等等去掉之后，会调用这个钩子。</p>\n<p>1.0、keep-alive独有的生命周期</p>\n<p>1.0.1、deactivated</p>\n<p>用keep-alive包裹的组件在切换的时候不会销毁，它会缓存到内存里，然后执行deactivated。</p>\n<p>1.0.2、activated</p>\n<p>命中缓存渲染后会调用activated</p>\n<h3>2、父子组件通信</h3>\n<p>2.1、使用prop和emit</p>\n<p>父组件通过prop向子组件通信</p>\n<pre class=\"ql-syntax\">// 父组件\n&lt;template&gt;\n  &lt;child :data=\"propData\"&gt;&lt;/child&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  data(){\n    return{\n      propData:'test'\n    }\n  }\n}\n&lt;/script&gt;\n\n// 子组件\n&lt;template&gt;\n  &lt;div&gt;{{propData}}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n  props: {\n    propData: {\n      type: String,\n      default: ''\n    }\n  }\n}\n&lt;/script&gt;\n</pre>\n<p>子组件通过emit向父组件通信</p>\n<pre class=\"ql-syntax\">// 父组件\n&lt;template&gt;\n  &lt;child @chilClick=\"childClick\"&gt;&lt;/child&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{\n      childData: ''\n    }\n  },\n  methods: {\n    childClick(data){\n      this.childData = data\n    }\n  }\n}\n&lt;/script&gt;\n\n// 子组件\n&lt;template&gt;\n  &lt;div @click=\"transport\"&gt;&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{\n      transportData: '123'\n    }\n  },\n  methods:{\n    transport(){\n      this.$emit('childData', this.transportData)\n    }\n  }\n}\n&lt;/script&gt;\n</pre>\n<p>2.2使用provide和inject</p>\n<p>父组件使用provide声明要传输的数据，子组件使用inject接收数据</p>\n<pre class=\"ql-syntax\">// 父组件\n&lt;template&gt;\n  &lt;child&gt;&lt;/child&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{\n      transportData: '123'\n    }\n  },\n  provide(){\n    return this.transportData\n  }\n}\n&lt;/script&gt;\n\n// 子组件\n&lt;template&gt;\n  &lt;div&gt;{{transportData}}&lt;div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default{\n  data(){\n    return{}\n  }\n  inject: [transportData]\n}\n&lt;/script&gt;\n</pre>\n<p>2.3使用vuex</p>\n<pre class=\"ql-syntax\">// 省略\n</pre>\n<h3>3、兄弟组件通信</h3>\n<p>3.1、使用event bus</p>\n<pre class=\"ql-syntax\">// bus.js\nimport Vue form 'vue'\nexport default new Vue\n\n// 组件1\nimport Bus from './bus.js'\nexport default{\n  data(){\n    return{\n      msg: 'text'\n    }\n  },\n  methods:{\n    transport(){\n      Bus.$emit('communicate', this.msg)\n    }\n  }\n}\n\n// 组件2\nimport Bus from './bus.js'\nexport default{\n  data(){\n    return{\n      comData: ''\n    }\n  },\n  mounted:{\n    Bus.$on('communicate', (data) =&gt; {\n      this.comData = data\n    })\n  }\n}\n</pre>\n<p>3.2使用vuex</p>\n<pre class=\"ql-syntax\">// 省略\n</pre>\n<h3>4、vuex状态管理</h3>\n<p>vuex可以统一管理一个大型项目的数据，下面是vuex一个简单的例子</p>\n<pre class=\"ql-syntax\">// store.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store{\n  state: {\n    num: 1\n  },\n  mutations:{\n    increase(state){\n      state.num++\n    }\n  },\n  getters:{\n    number: state =&gt; {\n      return state.num+2\n    }\n  },\n  actions:{\n    increase(context){\n      context.commit('increase')\n    }\n  }\n}\n\n// 组件\nexport default{\n  data(){\n    return{\n      vuexData: ''\n    }\n  },\n  mounted(){\n    this.vuexData = this.$store.state.num\n  },\n  methods:{\n    add(){\n      this.$store.commit('increase') // 同步操作\n      this.$store.dispatch('increase') // 异步操作\n    }\n  }\n}\n</pre>",time:"2019",type:"HTML5",copyright:"original",query:{name:"Vue相关"},link:"/blogDetail",summary:"Vue.js是我们常用的一个前端框架，下面我们就来复习一下它",tag:["javascript","Vue.js"]},{title:"js基础复习",content:"<h3>1、js原始类型</h3>\n<p>js基本类型有Number，String，Boolean，Undefined，Null，Symbol这6种。</p>\n<h3>2、js对象类型</h3>\n<p>在js里面，除了6种基本类型之外，其他的都是对象类型。他们之间的区别是原始类型存储的是值，而对象类型存储的是指针。当我们将对象类型的变量赋值给其他变量的时候，实际上是将它的指针赋值给了另外那个变量。因此如果那个被赋值的变量数据被修改，也会导致这个变量的值被修改。\n</p><pre class=\"ql-syntax\">let a = [];\nlet b = a;\nb.push(1);\nconsole.log(a)  // 结果是 [1]\n</pre>\n<h3>3、typeof，instanceof</h3>\n<p>对typeof来说，它可以正确判断除了null之外的所有原始类型。而instanceof则可用于判断对象类型</p>\n<pre class=\"ql-syntax\">typeof 123 // 'number'\ntype 'abc' // 'string'\nlet test = function(){}\ntest instanceof Function // true\nlet arr = []\narr instanceof Array // true\n</pre>\n<h3>4、类型转换</h3>\n<p>4.1 转换为字符串</p>\n<p>可以使用String()，.toString()，隐式转换等方式</p>\n<pre class=\"ql-syntax\">String(123)  //  '123'  都可以转\n123.toString() // '123'  除了null和undefined都可以转。\n123 + ''    // '123'  都可以转\n</pre>\n<p>4.2 转换为数值</p>\n<p>可以使用Number()，parseInt()，parseFloat()，隐式转换等</p>\n<pre class=\"ql-syntax\">Number(true) // 1\nparseInt('127yt')  // 127\nparseFloat('0908.5fgy')  // 908.5\n'8765' - 0 //  8765\n</pre>\n<p>其中parseInt和parseFloat都是解析到无法继续解析的位置。parseInt可传入2个参数，可以对数值进行进制转换如 parseInt('10',8)就是将10变成8进制。</p>\n<p>4.3 转换成布尔值</p>\n<p>可以使用Boolean()，隐式转换等</p>\n<pre class=\"ql-syntax\">Boolean('false')  // true\n!! null           // false\n</pre>\n<h3>5、闭包</h3>\n<p>闭包是前端经常出现的一个东西。简单来说，闭包就是可以访问到其他函数内部变量的一个特殊函数。</p>\n<pre class=\"ql-syntax\">function a(){\n  let inside = 0;\n  function b(){\n    console.log(inside)\n  }\n  return b\n}\nlet test = a();\ntest()  // 0  打印出了a函数里面的变量inside\n</pre>\n<p>在函数a执行完后，inside因为b函数调用的关系没有被回收。这也是我们使用闭包时需要注意的地方。那就是不能滥用闭包，否则会影响页面性能。</p>\n<h3>6、 == 和 ===</h3>\n<p>使用==进行判断时，会发生隐式转换，即等式左右两边类型不一致时，会自动进行类型转换，然后再判断。</p>\n<p>而===则是直接进行判断，不会自己转换类型。</p>\n<pre class=\"ql-syntax\">'7' == 7   // true\ntrue == 1  // true\n'2' === 2  // false\n</pre>\n<h3>7、原型</h3>\n<p>js里，除了null之外，其他对象都有原型。这也是为什么我们新建了一个对象后就有一些方法可以调用。因为那是通过原型继承过来的。我们可以通过__proto__这个属性找到这个对象的原型。而这个对象的构造函数，可以通过__proto__的constructor属性找到。而构造函数本身也会有一个prototype属性指向原型。</p>\n<h3>8、var let const</h3>\n<p>首先这三个都是定义变量用的，但各有区别。</p>\n<p>var的话会存在变量提升的问题，let和const不会。</p>\n<pre class=\"ql-syntax\">console.log(a)    // undefined\nvar a = 1\nconsole.log(b)    // Cannot access 'b' before initialization\nlet b = 2\nconsole.log(c)    // Cannot access 'c' before initialization\nconst c = 3\n</pre>\n<p>let和const在全局作用域下声明的变量，也不会挂载在window上。</p>\n<pre class=\"ql-syntax\">let abc = '123'\nconsole.log(window.abc)  // undefined\n</pre>\n<p>let声明的变量值可以改变，const的不行。</p>\n<pre class=\"ql-syntax\">let abcd = 1234\nabcd += 1\nconsole.log(abcd)  // 1235\nconst dcba = 4321\ndcba -= 1\nconsole.log(dcba)  // Assignment to constant variable.\n</pre>\n<h3>9、深浅拷贝</h3>\n<p>我们在拷贝对象类型的时候，实际上拷贝的是指针，所以当其中一个改变另外一个也会跟着改变。如何避免？我们可以使用浅拷贝。</p>\n<p>浅拷贝可是使用Object.assign来解决。它会拷贝所有的属性到新对象。</p>\n<pre class=\"ql-syntax\">//浅拷贝\nlet a = {\n  abc: 123\n}\nlet b = Object.assign({}, a)\na.abc = 321\nconsole.log(b.abc)  // 123\n\n// es6可使用...运算符来实现浅拷贝\nlet c = {\n  cba: 123\n}\nlet d = {...c}\nc.cba = 321\nconsole.log(d.cba)  // 123\n</pre>\n<p>如果属性值是对象的话，此时浅拷贝的依然是地址，如果希望拷贝的也是对象的话，就需要使用深拷贝。</p>\n<pre class=\"ql-syntax\">//深拷贝\nlet deep = {\n  abc: 123,\n  bcd: {\n    cdf: 321\n  }\n}\nlet deepcopy = JSON.parse(JSON.stringify(deep))\ndeep.bcd.cdf = 456\nconsole.log(deepcopy.bcd.cdf)  // 321\n</pre>\n<p>使用这个方法的时候需要注意，undefined，Symbol和函数会被忽略。</p>",time:"2019",type:"Javascript",copyright:"original",query:{name:"js基础复习"},link:"/blogDetail",summary:"在js里面，除了6种基本类型之外，其他的都是对象类型",tag:["javascript","es6"]},{title:"实现一个简单的双向绑定",content:'<p>我们知道，在vue里我们可以使用v-model来实现双向绑定，那如果我们想要自己实现一个双向绑定，该怎么做呢？</p>\n<p>我们可以借助Object.defineProperty来做到这一点。</p>\n<p>以下是MDN上对Object.defineProperty的介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank">Object.defineProperty</a></p>\n<p>从这里我们可以知道，在给对象某个属性赋值的时候，会调用里面的set方法。由此我们可以通过给某个对象绑定一个属性值的方式来实现双向绑定</p>\n<pre class="ql-syntax">&lt;input type=\'text\' id="input"&gt;\n&lt;div id="div"&gt;&lt;/div&gt;\n&lt;script&gt;\n  let obj = {}\n  const input = document.querySelector(\'#input\')\n  const div = document.querySelector(\'#div\')\n  Object.defineProperty(obj, \'bind\', {\n    set: (val) =&gt; {\n      input.value = val\n      div.innerHTML = val\n    }\n  })\n  input.onkeyup = () =&gt; {\n    obj.bind = input.value\n  }\n&lt;/script&gt;\n</pre>\n<p>到此我们就大概完成了vue上v-model="obj.bind"这样的操作。</p>\n<p>不过，还有没有更加新一点的方法去实现？</p>\n<p>当然是有的，那就是使用Proxy对象去实现。</p>\n<p>以下是Proxy的MDN文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank">Proxy</a></p>\n<pre class="ql-syntax">&lt;input type="text" id="input"&gt;\n&lt;div id="div"&gt;&lt;/div&gt;\n&lt;script&gt;\n  const input = document.querySelector(\'#input\')\n  const div = document.querySelector(\'#div\')\n  let handler = {\n    set: (obj, prop, newval) = {\n      input.value = newval\n      div.innerHTML = newval\n    }\n  }\n  let obj = new Proxy({}, handler)\n  input.onkeyup = () =&gt; {\n    obj.bind = input.value\n  }\n&lt;/script&gt;\n</pre>\n<iframe height="265" style="width: 100%;" scrolling="no" title="OewPwv" src="//codepen.io/vinson2088/embed/OewPwv/?height=265&theme-id=0&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">\n  See the Pen <a href=\'https://codepen.io/vinson2088/pen/OewPwv/\'>OewPwv</a> by 陈文鑫\n  (<a href=\'https://codepen.io/vinson2088\'>@vinson2088</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>',time:"2019",type:"Javascript",copyright:"original",query:{name:"实现一个简单的双向绑定"},link:"/blogDetail",summary:"我们知道，在vue里我们可以使用v-model来实现双向绑定，那如果我们想要自己实现一个双向绑定，该怎么做呢？",tag:["Javascript"]},{title:"初探event loop",content:"<p>先来看一道题，看看输出结果是什么</p>\n<pre class=\"ql-syntax\">console.log('1');\nsetTimeout(() =&gt; {\n  console.log('2');\n  new Promise((resolve, reject) =&gt; {\n    console.log('3');\n    resolve()\n  }).then(() =&gt; {\n    console.log('4');\n  })\n}, 0)\nsetTimeout(() =&gt; {\n  console.log('5');\n}, 0)\nnew Promise((resolve, reject) =&gt; {\n  console.log('6');\n  resolve()\n}).then(() =&gt; {\n  console.log('7')\n})\nconsole.log('8') </pre>\n<p>为了搞清楚这些语句执行的先后顺序，我们就必须要知道event loop机制。</p>\n<p> 我们都知道， js是单线程的， 而为了不让某一步卡死页面而做出来一个称为“ 异步” 的东西。 实际上所谓的异步， 就是将语句从主线程上拎出来放在旁边一个队列里， 等待主线程里的东西执行完毕， 再执行这里的东西。 于是我们可以知道， 在主线程之外， 还有一个任务队列的存在。</p>\n<p>而js任务又有着“宏任务(task)”和“微任务(Microtasks)”的分别。一般微任务会紧跟在宏任务后面执行。宏任务一般包括script语句，setTimeout，setInterval，requestAnimationFrame。微任务则包括Promise的then和catc还有finally，MutationObserver。知道了这些，我们就可以对上面的题目进行解析了。</p>\n<p> 首先js遇到了console.log语句， 便打印一个1出来， 然后遇到了setTimeout语句， 这是异步操作， 所以在旁边的任务队列创建了一个任务。 紧接着又是一个setTimeout， 所以又在任务队列里创建了另一个任务。 然后继续往下遇到Promise， 注意这里是下方的promise， 上方的promise因为包含在setTimeout里， 现在还在任务队列里排队呢。 继续刚才的分析， js进入promise打印出来6。 然后在promise出来， 打印一个8。 此时主线程上的宏任务就执行完毕了。 那此时有没有微任务？ 当然是有的， 刚刚说了promise.then就是微任务， 于是js执行微任务打印出来7。 然后微任务执行完毕。 这是主线程上就真的没东西了。 所以任务队列里排第一个的任务进行主线程。 也就是刚刚因为setTimeout一直在排队的语句现在开始执行。 首先先是打印出来2， 然后又是promise， 同样道理， 进入promise打印出来3， 此时主线程的宏任务执行完毕， 再执行微任务打印出来4。 这时主线程又空了， 所以任务队列下一个任务进来， 打印出来5。 所以最后的结果就是 1 6 8 7 2 3 4 5。</p>",time:"2019",type:"Javascript",copyright:"original",query:{name:"初探event loop"},link:"/blogDetail",summary:"先来看一道题，看看输出结果是什么",tag:["event loop","javascript","promise"]}]},"3d01":function(n,e,t){"use strict";var a=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"nav"},[t("el-menu",{staticClass:"el-menu-demo",attrs:{router:"","default-active":n.index,mode:"horizontal","background-color":"#409eff","text-color":"#fff","active-text-color":"#fff"},on:{select:n.handleSelect}},[t("el-menu-item",{attrs:{index:"1"}},[t("el-input",{attrs:{placeholder:"请输入内容"},model:{value:n.search,callback:function(e){n.search=e},expression:"search"}},[t("i",{staticClass:"el-input__icon el-icon-search",attrs:{slot:"suffix"},slot:"suffix"})])],1),t("el-menu-item",{attrs:{index:"/"}},[t("i",{staticClass:"el-icon-house"}),t("span",{attrs:{slot:"title"},slot:"title"},[n._v("主页")])]),t("el-menu-item",{attrs:{index:"3"}},[t("i",{staticClass:"el-icon-user"}),t("span",{attrs:{slot:"title"},slot:"title"},[n._v("关于我")])]),t("el-menu-item",{attrs:{index:"/blog"}},[t("i",{staticClass:"el-icon-date"}),t("span",{attrs:{slot:"title"},slot:"title"},[n._v("博客")])])],1)],1)},s=[],r={props:{index:{type:String,default:"/"}},name:"navigation",data:function(){return{activeIndex:"2",search:""}},methods:{handleOpen:function(){},handleClose:function(){},handleSelect:function(){}}},p=r,l=(t("acd5"),t("2877")),i=Object(l["a"])(p,a,s,!1,null,"7af324aa",null);e["a"]=i.exports},6098:function(n,e,t){},acd5:function(n,e,t){"use strict";var a=t("6098"),s=t.n(a);s.a}}]);
//# sourceMappingURL=chunk-241e0006.4d48f9b7.js.map